package buf

import (
	"fmt"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/bazelbuild/bazel-gazelle/language"
	"github.com/bazelbuild/bazel-gazelle/repo"
	"github.com/bazelbuild/bazel-gazelle/resolve"
	"github.com/bazelbuild/bazel-gazelle/rule"
)

type bufRule interface {
	// Kind of the buf rule, Ex: buf_lint_test.
	Kind() string
	// KindInfo returns the KindInfo of this rule.
	KindInfo() rule.KindInfo
	// LoadInfo returns the LoadInfo for this rule
	LoadInfo() rule.LoadInfo
	// GenRule returns a list of rules that need be generated for each `proto_library` rule.
	GenRule(protoRule *rule.Rule, c *Config) (*rule.Rule, interface{})
	// ShouldRemoveRule determines if this rule should be removed from the file. Typically rules generated in the previous run.
	ShouldRemoveRule(r *rule.Rule, protoRules map[string]*rule.Rule) bool
}

const lang = "buf"

type bufLang struct {
	rules   []bufRule
	ruleMap map[string]bufRule
}

// NewLanguage is called by Gazelle to install this language extension in a binary.
func NewLanguage() language.Language {
	rules := []bufRule{
		lintRule{},
		breakingRule{},
	}
	ruleMap := make(map[string]bufRule)
	for _, r := range rules {
		ruleMap[r.Kind()] = r
	}
	return &bufLang{
		rules:   rules,
		ruleMap: ruleMap,
	}
}

// Name returns the name of the language. This should be a prefix of the
// kinds of rules generated by the language, e.g., "go" for the Go extension
// since it generates "go_library" rules.
func (*bufLang) Name() string {
	return lang
}

// Kinds returns a map of maps rule names (kinds) and information on how to
// match and merge attributes that may be found in rules of those kinds. All
// kinds of rules generated for this language may be found here.
func (l *bufLang) Kinds() map[string]rule.KindInfo {
	res := make(map[string]rule.KindInfo)
	for _, br := range l.rules {
		res[br.Kind()] = br.KindInfo()
	}
	return res
}

func (*bufLang) Imports(c *config.Config, r *rule.Rule, f *rule.File) []resolve.ImportSpec {
	return []resolve.ImportSpec{
		{
			Lang: lang,
			Imp:  fmt.Sprintf("//%s:%s", f.Pkg, r.Name()),
		},
	}
}

func (*bufLang) Embeds(r *rule.Rule, from label.Label) []label.Label {
	return nil
}

func (*bufLang) Resolve(c *config.Config, ix *resolve.RuleIndex, rc *repo.RemoteCache, r *rule.Rule, imports interface{}, from label.Label) {
}

func (l *bufLang) Loads() []rule.LoadInfo {
	var loadInfos []rule.LoadInfo
	loadInfoMap := map[string]rule.LoadInfo{}
	for _, r := range l.rules {
		temp := r.LoadInfo()
		li := loadInfoMap[temp.Name]
		li.Name = temp.Name
		li.Symbols = append(li.Symbols, temp.Symbols...)
		loadInfoMap[temp.Name] = li
	}

	for _, v := range loadInfoMap {
		loadInfos = append(loadInfos, v)
	}
	return loadInfos
}

func (l *bufLang) GenerateRules(args language.GenerateArgs) language.GenerateResult {
	var (
		genRules   []*rule.Rule
		emptyRules []*rule.Rule
		imports    []interface{}
		protoRules = make(map[string]*rule.Rule)
	)

	cfg := GetConfig(args.Config)

	for _, pr := range args.OtherGen {
		if pr.Kind() != "proto_library" {
			continue
		}
		protoRules[pr.Name()] = pr

		for _, bufRule := range l.rules {
			r, i := bufRule.GenRule(pr, cfg)
			if r != nil {
				genRules = append(genRules, r)
				imports = append(imports, i)
			}
		}
	}

	if args.File != nil {
		for _, r := range args.File.Rules {
			bufRule := l.ruleMap[r.Kind()]
			if bufRule == nil || !bufRule.ShouldRemoveRule(r, protoRules) {
				continue
			}

			emptyRules = append(emptyRules, r)
		}
	}

	return language.GenerateResult{
		Gen:     genRules,
		Empty:   emptyRules,
		Imports: imports,
	}
}

func (*bufLang) Fix(c *config.Config, f *rule.File) {}
